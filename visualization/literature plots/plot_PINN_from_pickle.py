"""
plot_PINN_from_pickle.py
-------------------------
This script loads the curated time-series and loss data from the 
'pinn_plot_data.pkl' file generated by pH_PINN.py and reproduces all
the final analysis and comparison plots.

This allows for visualization to be run independently from model training.
"""

import pickle
import os
import numpy as np
import matplotlib.pyplot as plt


def main():
    """
    Loads the pickle data and generates all plots.
    """
    # ==========================================================================
    # 1. SETUP PATHS AND LOAD DATA
    # ==========================================================================

    # Define paths relative to this script's location
    # This script is in (root)/visualization/literature plots/
    # The data is in (root)/results/PINN Data/
    script_dir = os.path.dirname(os.path.abspath(__file__))
    pickle_path = os.path.join(script_dir, '..', '..', 'results', 'PINN Data', 'pinn_plot_data.pkl')
    output_dir = os.path.join(script_dir, '..', '..', 'results', 'PINN Plots')
    os.makedirs(output_dir, exist_ok=True)

    print(f"Loading plotting data from: {pickle_path}")
    try:
        with open(pickle_path, 'rb') as f:
            data = pickle.load(f)
        print("Data loaded successfully.")
    except FileNotFoundError:
        print(f"ERROR: Data file not found at '{pickle_path}'")
        print("Please run the pH_PINN.py script first to generate the data file.")
        return

    # ==========================================================================
    # 2. UNPACK DATA FROM DICTIONARY
    # ==========================================================================

    # Unpack all variables from the dictionary for easier access
    t_test = data['t_test']
    # split_start = data['split_start']
    # split_end = data['split_end']

    split_start = 0
    split_end = 100000

    # Loss Histories
    train_losses = data['train_losses']
    val_losses = data['val_losses']
    hamiltonian_losses = data['hamiltonian_losses']
    phys_losses = data['phys_losses']
    conservative_losses = data['conservative_losses']
    dissipative_losses = data['dissipative_losses']
    data_unified_losses = data['data_unified_losses']
    physics_residual_losses = data['physics_residual_losses']
    j_structure_losses = data['j_structure_losses']
    r_structure_losses = data['r_structure_losses']

    # Plot Data
    H_analytical_vis = data['H_analytical_vis']
    H_learned_aligned = data['H_learned_aligned']
    e_dot_test = data['e_dot_test']
    e_dot_autodiff = data['e_dot_autodiff']
    e_dot_from_equations = data['e_dot_from_equations']
    e_dot_from_structure = data['e_dot_from_structure']
    x_dot_test = data['x_dot_test']
    x_dot_autodiff = data['x_dot_autodiff']
    x_dot_from_vectorfield_vis = data['x_dot_from_vectorfield_vis']
    e_test = data['e_test']
    e_pred = data['e_pred']
    x_test = data['x_test']
    x_pred = data['x_pred']
    dHdt_analytical_vis = data['dHdt_analytical_vis']
    dHdt_pred_true = data['dHdt_pred_true']
    dHdt_pred_structure = data['dHdt_pred_structure']
    dHdt_pred_autodiff = data['dHdt_pred_autodiff']
    dHdt_pred_pH = data['dHdt_pred_pH']

    print("All required data has been unpacked.")

    # ==========================================================================
    # 3. GENERATE PLOTS
    # ==========================================================================
    print("Generating plots...")

    # --- Plot 1: Learned vs Analytical Hamiltonian ---
    plt.figure(figsize=(16, 9))
    plt.plot(t_test[split_start:split_end], H_analytical_vis[split_start:split_end],
             label='Analytical Hamiltonian', color='blue', linewidth=3)
    plt.plot(t_test[split_start:split_end], H_learned_aligned[split_start:split_end],
             label='pH-PINN Hamiltonian', color='red')
    plt.xlabel("$t$", fontsize=30)
    plt.ylabel("$H$", fontsize=30)
    plt.legend(fontsize=20, loc='upper right')
    plt.title("(a)", fontsize=30)
    plt.grid(True)
    plt.tick_params(axis='both', which='major', labelsize=25)
    plt.tight_layout()
    plt.savefig(os.path.join(output_dir, 'hamiltonian_comparison.png'), dpi=300)
    plt.savefig(os.path.join(output_dir, 'hamiltonian_comparison.eps'))

    # --- Plot 2: Detailed Loss Histories ---
    plt.figure(figsize=(16, 9))
    min_val_epoch = np.argmin(val_losses)
    color_map = {
        'train': 'tab:blue',
        'val': 'tab:orange',
        'data_unified': 'tab:green',
        'physics_residual': 'tab:red',
        'phys': 'tab:purple',
        'j_structure': 'tab:brown',
        'r_structure': 'tab:pink',
        'conservative': 'tab:olive',
        'dissipative': 'tab:cyan',
        'hamiltonian': 'tab:gray'
    }

    plt.plot(train_losses, label='Total Training', color=color_map['train'], linewidth=2)
    plt.plot(val_losses, label='Total Validation', color=color_map['val'], linewidth=2)
    plt.plot(data_unified_losses, label='Data Fidelity', color=color_map['data_unified'], linewidth=2)
    plt.plot(physics_residual_losses, label='Physics Residual', color=color_map['physics_residual'], linewidth=2)
    plt.plot(phys_losses, label='pH Structure', color=color_map['phys'], linewidth=2)
    plt.plot(j_structure_losses, label='J Fidelity', color=color_map['j_structure'], linewidth=2)
    plt.plot(r_structure_losses, label='R Fidelity', color=color_map['r_structure'], linewidth=2)
    plt.plot(conservative_losses, label='Conservative', color=color_map['conservative'], linewidth=2)
    plt.plot(dissipative_losses, label='Dissipative', color=color_map['dissipative'], linewidth=2)
    plt.plot(hamiltonian_losses, label='Hamiltonian (Monitor)', color=color_map['hamiltonian'], linewidth=2)

    # Draw vertical line at minimum validation loss
    plt.axvline(x=min_val_epoch, color='black', linestyle='--', linewidth=2,
                label=f'Min Val Loss @ Epoch {min_val_epoch}')

    plt.yscale('log')
    plt.xlabel('Epoch', fontsize=25)
    plt.ylabel('Loss (Log Scale)', fontsize=25)
    plt.legend(fontsize=18, loc='upper right', ncol=3)
    plt.grid(True, which="both", ls="--", alpha=0.6)
    plt.tick_params(axis='both', which='major', labelsize=20)
    plt.tight_layout()
    plt.savefig(os.path.join(output_dir, 'training_losses.png'), dpi=300)
    plt.savefig(os.path.join(output_dir, 'training_losses.eps'))


    # --- Plot 3: Error Derivative Fidelity (e_dot) ---
    fig, axes = plt.subplots(e_test.shape[1], 1, figsize=(12, 12), sharex=True)
    state_labels_e_dot = [r'$\dot{e}_x$', r'$\dot{e}_y$', r'$\dot{e}_z$', r'$\dot{e}_u$', r'$\dot{e}_\phi$']
    for i in range(e_test.shape[1]):
        axes[i].plot(t_test[split_start:split_end], e_dot_test[split_start:split_end, i],
                     label='True Derivative', color='green', linewidth=2)
        # axes[i].plot(t_test[split_start:split_end], e_dot_autodiff[split_start:split_end, i],
        #              label='Autodiff', color='orange')
        axes[i].plot(t_test[split_start:split_end], e_dot_from_equations[split_start:split_end, i],
                     label='Differential Eq.', color='purple')
        axes[i].plot(t_test[split_start:split_end], e_dot_from_structure[split_start:split_end, i],
                     label='pH Structure', color='red')
        axes[i].set_ylabel(state_labels_e_dot[i], fontsize=25)
        axes[i].grid(True)
        axes[i].tick_params(axis='both', which='major', labelsize=16)
    axes[0].legend(loc='upper right', fontsize=18)
    axes[-1].set_xlabel("$t$", fontsize=25)
    plt.tight_layout()
    fig.savefig(os.path.join(output_dir, 'error_derivative_fidelity.png'), dpi=300)
    fig.savefig(os.path.join(output_dir, 'error_derivative_fidelity.eps'))


    # --- Plot 4: HR Derivative Fidelity (x_dot) ---
    fig, axes = plt.subplots(x_test.shape[1], 1, figsize=(12, 18), sharex=True)
    state_labels_x_dot = [r'$\dot{x}_1$', r'$\dot{y}_1$', r'$\dot{z}_1$', r'$\dot{u}_1$', r'$\dot{\phi}_1$',
                          r'$\dot{x}_2$', r'$\dot{y}_2$', r'$\dot{z}_2$', r'$\dot{u}_2$', r'$\dot{\phi}_2$']
    for i in range(x_test.shape[1]):
        axes[i].plot(t_test[split_start:split_end], x_dot_test[split_start:split_end, i],
                     label='True Derivative', color='green', linewidth=2)
        # axes[i].plot(t_test[split_start:split_end], x_dot_autodiff[split_start:split_end, i],
        #              label='Autodiff', color='orange')
        axes[i].plot(t_test[split_start:split_end], x_dot_from_vectorfield_vis[split_start:split_end, i],
                     label='Differential Eq.', color='purple')
        axes[i].set_ylabel(state_labels_x_dot[i], fontsize=25)
        axes[i].grid(True)
        axes[i].tick_params(axis='both', which='major', labelsize=16)
    axes[0].legend(loc='upper right', fontsize=18)
    axes[-1].set_xlabel("$t$", fontsize=25)
    plt.tight_layout()
    fig.savefig(os.path.join(output_dir, 'hr_derivative_fidelity.png'), dpi=300)
    fig.savefig(os.path.join(output_dir, 'hr_derivative_fidelity.eps'))


    # --- Plot 5: Error State Trajectories (e) ---
    fig, axes = plt.subplots(e_test.shape[1], 1, figsize=(12, 12), sharex=True)
    state_labels_error = [r'$e_x$', r'$e_y$', r'$e_z$', r'$e_u$', r'$e_\phi$']
    for i in range(e_test.shape[1]):
        axes[i].plot(t_test[split_start:split_end], e_test[split_start:split_end, i],
                     'b', label='True State', linewidth=2)
        axes[i].plot(t_test[split_start:split_end], e_pred[split_start:split_end, i],
                     'r', label='pH-PINN State')
        axes[i].set_ylabel(state_labels_error[i], fontsize=25)
        axes[i].grid(True)
        axes[i].tick_params(axis='both', which='major', labelsize=16)
    axes[0].legend(loc='upper right', fontsize=18)
    axes[-1].set_xlabel("$t$", fontsize=25)
    plt.tight_layout()
    fig.savefig(os.path.join(output_dir, 'error_state_e_prediction.png'), dpi=300)
    fig.savefig(os.path.join(output_dir, 'error_state_e_prediction.eps'))


    # --- Plot 6: HR State Trajectories (x) ---
    fig, axes = plt.subplots(x_test.shape[1], 1, figsize=(12, 18), sharex=True)
    state_labels_x = [r'$x_1$', r'$y_1$', r'$z_1$', r'$u_1$', r'$\phi_1$',
                      r'$x_2$', r'$y_2$', r'$z_2$', r'$u_2$', r'$\phi_2$']
    for i in range(x_test.shape[1]):
        axes[i].plot(t_test[split_start:split_end], x_test[split_start:split_end, i],
                     'b', label='True State', linewidth=2)
        axes[i].plot(t_test[split_start:split_end], x_pred[split_start:split_end, i],
                     'r', label='pH-PINN State')
        axes[i].set_ylabel(state_labels_x[i], fontsize=25)
        axes[i].grid(True)
        axes[i].tick_params(axis='both', which='major', labelsize=16)
    axes[2].legend(loc='upper right', fontsize=18)
    axes[-1].set_xlabel("$t$", fontsize=14)
    plt.tight_layout()
    fig.savefig(os.path.join(output_dir, 'hr_state_x_prediction.png'), dpi=300)
    fig.savefig(os.path.join(output_dir, 'hr_state_x_prediction.eps'))

    # --- Plot 7: dH/dt Comparison ---
    plt.figure(figsize=(16, 9))
    plt.plot(t_test[split_start:split_end], dHdt_analytical_vis[split_start:split_end],
             label=r'Analytical $dH/dt$', linewidth=3, color='blue')
    # plt.plot(t_test[split_start:split_end], dHdt_pred_true[split_start:split_end]*(-1),
    #          label=r'$\nabla H \cdot \dot e_{\mathrm{true}}$',color='red')
    # plt.plot(t_test[split_start:split_end], dHdt_pred_autodiff[split_start:split_end]*(-1),
    #          label=r'$\nabla H \cdot \dot e_{\mathrm{autodiff}}$', color='red')
    plt.plot(t_test[split_start:split_end], dHdt_pred_pH[split_start:split_end]*(-1),
             label=r'pH-PINN $dH/dt$', color='red')
    plt.xlabel('$t$', fontsize=30);
    plt.ylabel(r'$dH/dt$', fontsize=30)
    plt.legend(fontsize=20, loc='upper right')
    plt.tight_layout()
    plt.grid(True)
    plt.tick_params(axis='both', which='major', labelsize=25)
    plt.title("(b)", fontsize=30)
    plt.tight_layout()
    plt.savefig(os.path.join(output_dir, 'dHdt_comparison.png'), dpi=300)
    plt.savefig(os.path.join(output_dir, 'dHdt_comparison.eps'))

    # --- Plot 8 & 9: Mean J and R Matrices (loaded from pickle) -------------
    J_mean = np.asarray(data['J_mean'])
    R_mean = np.asarray(data['R_mean'])

    var_labels = [r'$e_x$', r'$e_y$', r'$e_z$', r'$e_u$', r'$e_\phi$']

    def plot_matrix_with_numbers(mat, title, filename):
        plt.figure(figsize=(6.2, 5.4))
        ax = plt.gca()

        # Mask zero entries so they are not colored by the colormap
        masked_mat = np.ma.masked_where(mat == 0, mat)

        # Plot background as light gray (for zeros)
        ax.imshow(np.zeros_like(mat), cmap='gray', vmin=0, vmax=1, alpha=0.15)

        # Overlay non-zero entries using seismic colormap
        cmap = plt.cm.seismic
        im = ax.imshow(masked_mat, interpolation='nearest', aspect='equal', cmap=cmap)

        plt.title(title, fontsize=20)
        plt.xticks(np.arange(5), var_labels, rotation=0, fontsize=14)
        plt.yticks(np.arange(5), var_labels, fontsize=14)

        # Colorbar at top with custom label
        cbar = plt.colorbar(im, fraction=0.046, pad=0.04)

        # Grid lines between cells
        ax.set_xticks(np.arange(-0.5, mat.shape[1], 1), minor=True)
        ax.set_yticks(np.arange(-0.5, mat.shape[0], 1), minor=True)
        ax.grid(which='minor', color='k', linestyle='-', linewidth=0.7)
        ax.tick_params(which='minor', bottom=False, left=False)

        # Add numeric values — adapt color to background brightness
        norm = im.norm
        for i in range(mat.shape[0]):
            for j in range(mat.shape[1]):
                val = mat[i, j]
                if val == 0:
                    txt_color = 'black'
                else:
                    # Get background RGB from colormap
                    rgba = cmap(norm(val))
                    r, g, b = rgba[:3]
                    # Compute luminance to decide text color
                    luminance = 0.299 * r + 0.587 * g + 0.114 * b
                    txt_color = 'black' if luminance > 0.5 else 'white'
                plt.text(j, i, f"{val:.3g}", ha='center', va='center',
                         color=txt_color, fontsize=12)

        plt.tight_layout()
        plt.savefig(os.path.join(output_dir, filename + ".png"), dpi=500)
        plt.savefig(os.path.join(output_dir, filename + ".eps"))
        plt.close()

    # Plot and save both matrices
    plot_matrix_with_numbers(J_mean, "(a)", "J_mean_matrix")
    plot_matrix_with_numbers(R_mean, "(b)", "R_mean_matrix")


    plt.close('all')
    print(f"\n✅ All plots have been generated and saved to '{output_dir}'")


if __name__ == "__main__":
    main()